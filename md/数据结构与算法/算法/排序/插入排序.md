# 插入排序

## 定义

插入排序（Insertion Sort）：它的工作原理与手动整理一副牌的过程非常相似，通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

## 算法步骤

1. **初始状态**：假设第一个元素是已排序的部分，而其余部分是待排序的部分；
2. **比较与插入**：从待排序的部分选择一个元素，将其与已排序部分的元素从后往前逐个进行比较，找到第一个小于等于待排序元素的位置，然后将待排序元素插入到该位置（如果待排序元素与已排序部分的元素相等，则将待排序元素插入到相等元素的后面）；
3. 重复第二步，直至所有元素都被插入到已排序部分。

![img](https://fastly.jsdelivr.net/gh/xihuanxiaorang/img/202309182046455.gif)

## 代码实现

```java
/**
 * 插入排序
 *
 * @param nums 待排序的数组
 */
private void insertionSort(int[] nums) {
    // 由于第一个元素已经是有序区，所以 i 从 1 开始
    for (int i = 1; i < nums.length; i++) {
        // 由于插入位置是和有序区的元素比较，所以 j = i - 1
        int j = i - 1;
        // 设置基准元素为当前元素
        int base = nums[i];
        // 内层循环用于比较有序区的元素并找到插入位置
        // 如果当前元素比有序区的元素小，就将有序区的元素后移一位
        // 如果当前元素比有序区的元素大，说明找到了插入位置，退出循环
        // 由于有序区的元素是从后往前比较的，所以有序区的元素会依次后移
        // 当有序区的元素后移之后，就相当于空出了一个位置，这个位置就是插入位置
        while (j >= 0 && nums[j] > base) {
            nums[j + 1] = nums[j];
            j--;
        }
        // 将当前元素插入到插入位置
        nums[j + 1] = base;
    }
}
```

## 特点

- 时间复杂度：
  - 在最好的情况下，即数组完全有序时，每次插入操作时当前数只需和前一个数比较一下就可以了，因此时间复杂度为 O(n)；
  - 在最坏的情况下，即数组完全逆序时，每次插入操作分别需要循环 n-1、n-2、…、2、1 次，求和得到 n*(n-1)/2，因此时间复杂度为 O(n^2^)；
  - 平均时间复杂度为 O(n^2^)；
- 空间复杂度为 O(1)，原地排序，不需要额外的空间；
- 稳定排序：相等元素的相对位置不会改变；
- 在小型数据集或已接近有序的数据集上性能良好，但在大型数据集上性能较差。
