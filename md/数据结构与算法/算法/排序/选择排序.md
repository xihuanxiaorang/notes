# 选择排序

## 算法步骤

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；
3. 以此类推，直至所有元素均排序完毕。

![img](https://fastly.jsdelivr.net/gh/xihuanxiaorang/img/202309182046543.gif)

## 代码实现

```java
/**
 * 选择排序
 *
 * @param nums 待排序的数组
 */
private void selectionSort(int[] nums) {
    // 外层循环控制比较的轮数，最多需要比较 n-1 轮
    // 每一轮比较之后，无序区的长度都会减1
    // 所以下一轮比较的时候，内层循环的边界就是上一轮比较的最后位置
    // 由于最后一轮只剩一个元素，所以不需要比较，因此 i < nums.length - 1
    for (int i = 0; i < nums.length - 1; i++) {
        // 用于记录最小元素的下标
        int minIndex = i;
        // 内层循环用于比较无序区的元素并找出最小元素的下标
        for (int j = i + 1; j < nums.length; j++) {
            // 如果当前元素比最小元素小，更新最小元素的下标
            if (nums[j] < nums[minIndex]) {
                // 更新最小元素的下标
                minIndex = j;
            }
        }
        // 如果最小元素不是当前元素，则交换位置
        if (minIndex != i) {
            swap(nums, i, minIndex);
        }
    }
}
```

## 特点

- 选择排序的最优时间复杂度、平均时间复杂度和最坏时间复杂度均为 O(n^2^)；
- 空间复杂度为 O(1)，原地排序，不需要额外的空间；
- **不稳定排序**：相等元素的相对位置会发生改变；在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。举个栗子，如数组 [5, 8, 5, 2, 9]，可知第一趟选择第 1 个元素 5 会和 2 进行交换，那么原序列中两个 5 的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。
