# 逆波兰表达式

## 定义

**逆波兰表达式（Reverse Polish Notation）** 又叫做 **后缀表达式**。逆波兰表达式是由波兰逻辑学家 J·卢卡西维兹于 1929 年首先提出的一种表达式的表示方法。后来，人们就把用这种表示法写出的表达式称作“逆波兰表达式”。**逆波兰表达式把操作数写在前面，把运算符写在后面**。

## 作用

🤔：实现逆波兰表达式的算法并不难，但是为什么要将一个看似简单的中缀表达式转换成一个复杂的逆波兰表达式呢？

🤓：原因就在于这个简单是相对于人类的思维结构来说的，对计算机而言中缀表达式时非常复杂的结构。相对的，逆波兰表达式在计算机看来却是比较简单易懂的结构。因为计算机普遍采用的内存结构是栈式结构，它执行后进先出的顺序。

## 中缀表达式转后缀表达式实现算法

🤔：那么将一个中缀表达式转换成后缀表达式该如何实现呢？

🤓：首先需要分配 2 个栈，一个作为临时存储运算符的栈 s1，一个作为存放结果（逆波兰表达式）的栈 s2。开始从左至右扫描中缀表达式，逐序进行如下步骤：

1. 若取出的字符是操作数，则分析出完整的运算数，将操作数直接压入 s2。
2. 若取出的字符是运算符，则将该运算符与 s1 栈顶元素比较，如果该运算符（不包括括号运算符）优先级高于 s1 栈顶运算符（包括左括号，左括号的优先级为 -1）的优先级，则将该运算符加到 s1 栈中，否则的话，将 s1 的栈顶运算符弹出加到 s2 栈中，直至 s1 栈顶运算符（包括左括号）低于（不包括等于）该运算符优先级时停止弹出运算符，最后将该运算符加到 s1 栈中。
3. 若取出的字符是左括号时，则直接加到 s1 栈中。
4. 若取出的字符是右括号时，则将距离 s1 栈顶最近的左括号之间的运算符逐个弹出栈加到 s2 栈中，此时抛弃左括号。
5. 重复上面的 1~4 步，直至处理完所有的输入字符。
6. 将 s1 栈中剩余的运算符依次弹出加到 s2 栈中。

完成以上步骤，s2 栈便为逆波兰表达式输出结果。不过 s2 应做一下逆序处理。

### 举例说明

下面举例说明：将中缀表达式 `1+((2+3)*4)-5` 转换为后缀表达式。

| 扫描到的元素 | s2（栈底 -> 栈顶）  | s1（栈底 -> 栈顶） | 说明                                                                                                                    |
| ------------ | ------------------- | ------------------ | ----------------------------------------------------------------------------------------------------------------------- |
| 1            | `1`                 |                    | 遇到操作数，直接压入 s2                                                                                                 |
| `+`          | `1`                 | `+`                | 遇到运算符，并且 s1 栈为空，将其压入 s1                                                                                 |
| `(`          | `1`                 | `+ (`              | 遇到左括号，直接压入 s1                                                                                                 |
| `(`          | `1`                 | `+ ( (`            | 遇到左括号，直接压入 s1                                                                                                 |
| 2            | `1 2`               | `+ ( (`            | 遇到操作数，直接压入 s2                                                                                                 |
| `+`          | `1 2`               | `+ ( ( +`          | 遇到运算符，与 s1 栈顶运算符的优先级比较，因为 `+` 的优先级比 `(` 的优先级高，将其压入 s1                               |
| 3            | `1 2 3`             | `+ ( ( +`          | 遇到操作数，直接压入 s2                                                                                                 |
| `)`          | `1 2 3 +`           | `+ (`              | 遇到右括号，将距离 s1 栈顶最近的左括号之间的运算符逐个弹出栈加到 s2 栈中，即将 `+` 压入 s2，丢弃栈顶的左括号            |
| `*`          | `1 2 3 +`           | `+ ( *`            | 遇到运算符，与 s1 栈顶运算符的优先级比较，因为 `*` 的优先级比 `(` 的优先级高，将其压入 s1                               |
| 4            | `1 2 3 + 4`         | `+ ( *`            | 遇到操作数，直接压入 s2                                                                                                 |
| `)`          | `1 2 3 + 4 *`       | `+`                | 遇到右括号，将距离 s1 栈顶最近的左括号之间的运算符逐个弹出栈加到 s2 栈中，即将 `*` 压入 s2，丢弃栈顶的左括号            |
| `-`          | `1 2 3 + 4 * +`     | `-`                | 遇到运算符，与 s1 栈顶运算符的优先级比较，因为 `-` 的优先级比 `+` 的优先级相等，则将栈顶的 `+` 弹出之后再将 `-` 压入 s1 |
| 5            | `1 2 3 + 4 * + 5`   | `-`                | 遇到操作数，直接压入 s2                                                                                                 |
|              | `1 2 3 + 4 * + 5 -` |                    | 将 s1 栈中剩余的运算符依次弹出加到 s2 栈中，即将 `-` 压入 s2                                                            |

由于 s2 是一个栈，弹出是从栈顶弹出，因此逆序后的结果就是后缀表达式 `1 2 3 + 4 * + 5 -`。

### 代码实现

将中缀表达式转成 List，方便在后续操作中直接获取数据，不再需要处理多位数这种情况！

```java
/**
 * 将中缀表达式解析成单个元素的 List，
 *
 * @param infixExpression 中缀表达式
 * @return 1+((2+3)*4)-5 -> [1,+,(,(,2,+,3,),*,4,),5]
 */
private static List<String> infixExp2List(String infixExpression) {
    List<String> res = new ArrayList<>();
    // 扫描并解析
    int i = 0;
    char ch;
    String tempNum = ""; // 支持多位数
    while (i < infixExpression.length()) {
        // 如果不是操作数，就是运算符，直接添加到容器中
        // 0 = 48, 9 = 57
        ch = infixExpression.charAt(i++);
        if (!(ch >= 48 && ch <= 57)) {
            // 碰到运算符时，就将前面积攒下来的多位数添加到容器中
            if (!tempNum.isEmpty()) {
                res.add(tempNum);
                tempNum = "";
            }
            // 然后再将该运算符添加到容器中
            res.add(ch + "");
            continue;
        }
        // 如果是操作数，则考虑处理多位数
        tempNum += ch;
        // 如果已经是最后一个字符了，则将这个多位数添加到容器中
        if (i == infixExpression.length()) {
            res.add(tempNum);
            tempNum = "";
        }
    }
    return res;
}
```

运算符的优先级比较，其中 `+` 和 `-` 的优先级相同，都为 `0`；`*` 和 `/` 的优先级相同，都为 `1`；其他的（包括左括号）优先级都为 `-1`。优先级从大到小为：`*`、`/` > `+`、`-` > `(`。

```java
/**
 * 计算操作符号优先级，暂时只支持 + - * /
 *
 * @param ch
 * @return 优先级越高，数值越大
 */
private int priority(char ch) {
    switch (ch) {
        case '+':
        case '-':
            return 0;
        case '*':
        case '/':
            return 1;
        default:
            return -1;
    }
}
```

将中缀表达式转成后缀表达式。

```java
/**
 * 中缀表达式 List 转换成后缀表达式 List
 *
 * @param infixExpressionList 中缀表达式 List
 * @return 后缀表达式 List
 */
public static List<String> infixExpressionList2SuffixExpressionList(List<String> infixExpressionList) {
    // 符号栈
    Stack<String> s1 = new Stack<>();
    // 思路是使用栈来存储表达式元素
    // 仔细观察他的解析步骤，会发现：只是在入栈，并未出现出栈操作
    // 而且，最后的结果还要逆序，所以这里使用 list，直接顺序读取出来就是最后的结果了
    List<String> s2 = new ArrayList<>();
    for (String item : infixExpressionList) {
        if (item.matches("\\d+")) {
            // 如果是数字，则加入 s2
            s2.add(item);
        } else if ("(".equals(item)) {
            // 如果是左括号，直接压入 s1
            s1.push(item);
        } else if (")".equals(item)) {
            // 如果是右括号，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到 左括号 为止
            while (!"(".equals(s1.peek())) {
                s2.add(s1.pop());
            }
            // 丢弃左括号
            s1.pop();
        } else {
            // 如果 s1 为空，或则栈顶运算符为 （，则压入符号栈 s1
            // 如果优先级比栈顶运算符 高，则压入符号栈 s1,否则，否则将 s1 栈顶的运算符弹出，压入 s2 中
            // 上面两句话，转换成下面的描述
            // 上面如果  s1 栈顶符号优先级比 当前符号高，则弹出加入到 s2 中。
            // 因为：如果栈顶符号是 （ 返回优先级为 -1.比当前符号低，则不会走该方法
            while (!s1.isEmpty() && (priority(s1.peek()) >= priority(item))) {
                s2.add(s1.pop());
            }
            s1.push(item);
        }
    }
    // 将 s1 中剩余的运算符依次弹出并加入 s2 中
    while (!s1.isEmpty()) s2.add(s1.pop());
    return s2;
}
```

## 计算后缀表达式的值

🤔：如何根据已知的后缀表达式计算出表达式的值呢？

🤓：首先初始化一个栈，开始从左至右扫描后缀表达式，逐序进行如下步骤：

1. 如果遇到的操作数，则直接将操作数压入栈中
2. 如果遇到的运算符，弹出栈顶的两个操作数（栈顶和次顶），用运算符对它们做相应的计算，并将计算后的结果压入栈中。需要注意的是，计算顺序为：次顶操作数 运算符 栈顶操作数。

然后重复以上步骤，直至整个表达式遍历结束，栈中的操作数即为表达式计算后的结果。

### 举例说明

下面举例说明：中缀表达式 `1+((2+3)*4)-5` 对应的后缀表达式为 `1 2 3 + 4 * + 5 -`。

| 扫描到的元素 | 栈（栈底 -> 栈顶） | 说明                                                                                 |
| ------------ | ------------------ | ------------------------------------------------------------------------------------ |
| 1            | `1`                | 遇到的是操作数，将 `1` 压入栈中                                                      |
| 2            | `1 2`              | 遇到的是操作数，将 `2` 压入栈中                                                      |
| 3            | `1 2 3`            | 遇到的是操作数，将 `3` 压入栈中                                                      |
| `+`          | `1 5`              | 遇到的是运算符，弹出栈顶的两个操作数，计算结果 = `2 + 3 = 5`，将结果 `5` 压入栈中    |
| 4            | `1 5 4`            | 遇到的是操作数，将 `4` 压入栈中                                                      |
| `*`          | `1 20`             | 遇到的是运算符，弹出栈顶的两个操作数，计算结果 = `5 * 4 = 20`，将结果 `20` 压入栈中  |
| `+`          | `21`               | 遇到的是运算符，弹出栈顶的两个操作数，计算结果 = `1 + 20 = 21`，将结果 `21` 压入栈中 |
| 5            | `21 5`             | 遇到的是操作数，将 `5` 压入栈中                                                      |
| `-`          | `16`               | 遇到的是运算符，弹出栈顶的两个操作数，计算结果 = `21 - 5 = 16`，将结果 `16` 压入栈中 |

表达式遍历结束之后，栈中的操作数 `16` 即为表达式计算后的结果。

### 代码实现

对应到 [力扣（LeetCode）- 计算后缀表达式的值](https://leetcode.cn/problems/8Zf90G/description/)

```java
/**
 * 计算后缀表达式的值，
 *
 * @param suffixExpressionList 后缀表达式List
 * @return 表达式结果值
 */
public static int evalRPN(List<String> suffixExpressionList) {
    Stack<Integer> stack = new Stack<>();
    for (String item : suffixExpressionList) {
        // 如果是操作数，则直接压入栈中
        if (item.matches("\\d+")) {
            stack.push(Integer.valueOf(item));
            continue;
        }
        Integer num2 = stack.pop(); // 栈顶操作数
        Integer num1 = stack.pop(); // 次顶操作数
        stack.push(cal(num1, num2, item));
    }
    return stack.pop();
}

/**
 * 次顶操作数 运算符 栈顶操作数
 *
 * @param num1     次顶操作数
 * @param num2     栈顶操作数
 * @param operator 运算符
 * @return 结果值
 */
private static int cal(int num1, int num2, String operator) {
    switch (operator) {
        case "+":
            return num1 + num2;
        case "-":
            return num1 - num2;
        case "*":
            return num1 * num2;
        case "/":
            return num1 / num2;
        default:
            throw new IllegalArgumentException("不支持的运算符：" + operator);
    }
}
```
