# Spring 面试题



## Spring 事务

事务的种类：**编程式事务**和**声明式事务**。

默认回滚规则：事务默认情况下只会在**运行时异常**（RuntimeException及其子类）和错误（Error）时进行回滚，不过可以通过 `@Transactional` 注解中的 `rollbackFor` 属性精确配置导致回滚的异常类型，包括受检异常（即非运行时异常）。

事务的隔离级别：实际对应的是数据库的事务隔离级别，对于 MySQL 数据库而言默认的事务隔离级别为**可重复读**；具体演示可参考 [MySQL 四种隔离级别](https://www.yuque.com/xihuanxiaorang/java/uebi2x7whkk44kg1)

- 读未提交（READ UNCOMMITTED）：提供了事务之间最小限度的隔离。允许读取其他事务还未提交的数据变更，可能会导致脏读、不可重复读和幻读；
- 读已提交（READ COMMITTED）：允许读取其他事务已经提交的数据变更，可以阻止脏读，但是不可重复读和幻读仍然有可能发生。
- 可重复读（REPEATABLE READ）：对同一数据的多次读取结果都是一样的，除非数据是被自身事务所修改，可以阻止脏读和不可重复读，但是幻读仍然有可能发生。
- 序列化（SERIALIZABLE）：提供了事务之间最大限度的隔离。所有事务依次逐个执行，这样事务之间就完全不可能产生干扰，可以阻止脏读、不可重复读以及幻读。

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ UNCOMMITTED | ❌    | ❌          | ❌    |
| READ COMMITTED   | ✔️    | ❌          | ❌    |
| REPEATABLE READ  | ✔️    | ✔️          | ❌    |
| SERIALIABLE      | ✔️    | ✔️          | ✔️    |

- 一个事务读到另外一个事务还没有提交的数据，称之为脏读。
- 不可重复读是指一个事务先后读取读取同一条记录，但两次读取的数据不同，称之为不可重复读。
- 在一个事务中按照条件查询数据时，发现没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，就好像产生了幻觉一样，这种情况就称之为幻读；

事务的传播行为：当多个事务同时存在的时候，一般指的是多个事务方法相互调用时，Spring 该如何处理这些事务的行为。默认的事务传播行为是 `REQUIRED`;

| 事务传播行为  | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| REQUIRED      | 支持使用当前事务，如果当前事务不存在，就创建一个新事务       |
| SUPPORTS      | 支持使用当前事务，如果当前事务不存在，就不使用事务，以非事务方式执行 |
| MANDATORY     | 强制，支持使用当前事务，如果当前事务不存在，就抛出异常       |
| REQUIRES_NEW  | 创建一个新事务，如果当前事务存在，就把当前事务挂起           |
| NOT_SUPPORTED | 以非事务方式执行，如果当前事务存在，就把当前事务挂起         |
| NESTED        | 嵌套事务，如果当前事务存在，则在嵌套的事务中执行；如果当前事务不存在，则表现与 REQUIRED 一样 |
| NEVER         | 不支持当前事务，如果当前事务存在，就抛出异常                 |

事务失效场景：

- 非 `public` 修饰的方法；
- 使用 try/catch 捕获异常；
- 直接内部调用同类中的方法；
- 抛出的异常与声明事务时指定的异常不一致；
- 数据库本身不支持事务，如 MySQL 中的 MyISAM 引擎；

